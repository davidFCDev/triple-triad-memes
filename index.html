<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Triple Triad Meme</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Bangers&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: #000000;
        font-family: "Bangers", sans-serif;
        overflow: hidden;
        touch-action: none;
      }
      #gameContainer {
        width: 100%;
        max-width: 500px;
        height: 100vh;
        max-height: 1000px;
        position: relative;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        image-rendering: pixelated;
      }
      #tutorial,
      #cardStealScreen,
      #cardSelectionScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgb(0, 0, 0);
        color: #ffffff;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 20px;
        box-sizing: border-box;
        z-index: 10;
        font-family: "Bangers", sans-serif;
      }
      #tutorial h1,
      #cardStealScreen h1,
      #cardSelectionScreen h1 {
        font-size: 46px;
        margin-bottom: 20px;
        background: linear-gradient(to right, #d63ce1, #31ff83);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }
      #tutorial p,
      #cardStealScreen p,
      #cardSelectionScreen p {
        font-size: 16px;
        margin: 10px 0;
      }
      #tutorial button,
      #cardStealScreen button,
      #cardSelectionScreen button {
        margin: 15px;
        padding: 15px 30px;
        font-size: 20px;
        border: 2px solid #ffffff;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Bangers", sans-serif;
        font-weight: bold;
        transition: transform 0.2s;
      }
      #tutorial button:hover,
      #cardStealScreen button:hover,
      #cardSelectionScreen button:hover {
        transform: scale(1.05);
      }
      #tutorial #startButton,
      #cardSelectionScreen #confirmButton {
        background: #d63ce1;
        color: #000000;
      }
      #tutorial #rulesButton {
        background: #31ff83;
        color: #000000;
        position: relative;
        padding-right: 40px;
      }
      #tutorial #rulesButton::after {
        content: "→";
        position: absolute;
        right: 15px;
        font-size: 20px;
      }
      #rulesModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 20;
        justify-content: center;
        align-items: center;
        padding: 20px;
        box-sizing: border-box;
      }
      #rulesModal .modal-content {
        background: #000000;
        color: #ffffff;
        padding: 20px;
        max-width: 400px;
        width: 100%;
        border: 2px solid #ffffff;
        font-family: "Bangers", sans-serif;
        font-size: 16px;
        text-align: left;
        line-height: 1.5;
      }
      #rulesModal .modal-content h2 {
        font-family: "Bangers", sans-serif;
        font-size: 24px;
        margin-bottom: 10px;
        color: #31ff83;
      }
      #rulesModal .modal-content p {
        margin: 10px 0;
      }
      #rulesModal .modal-content .rule-name {
        font-size: 20px;
        font-weight: bold;
        letter-spacing: 1px;
        color: #d63ce1;
      }
      #rulesModal .modal-content button {
        padding: 10px 20px;
        font-size: 16px;
        background: #000000;
        color: #ffffff;
        border: 2px solid #ffffff;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Bangers", sans-serif;
        font-weight: bold;
      }
      #cardStealScreen .card-container,
      #cardSelectionScreen .card-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        margin: 20px 0;
      }
      #cardStealScreen .card,
      #cardSelectionScreen .card {
        width: 90px;
        height: 126px;
        cursor: pointer;
        transition: transform 0.2s;
        position: relative;
      }
      #cardStealScreen .card:hover,
      #cardSelectionScreen .card:hover {
        transform: scale(1.05);
      }
      #cardStealScreen .card.selected,
      #cardSelectionScreen .card.selected {
        border: 2px solid #ffffff;
        transform: scale(1.05);
      }
      #cardSelectionScreen #confirmButton:disabled {
        background: #666666;
        cursor: not-allowed;
      }
      #cardSelectionScreen .pagination-container {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin: 10px 0;
      }
      #cardSelectionScreen .pagination-button {
        width: 40px; /* Fixed width */
        height: 30px; /* Fixed height */
        padding: 0;
        font-size: 14px;
        background: #31ff83; /* Green for enabled */
        color: #ffffff;
        border: 1px solid #ffffff;
        border-radius: 3px;
        cursor: pointer;
        font-family: "Bangers", sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: transform 0.2s;
      }
      #cardSelectionScreen .pagination-button:hover {
        transform: scale(1.05);
      }
      #cardSelectionScreen .pagination-button:disabled {
        background: #333333; /* Grey for disabled */
        cursor: not-allowed;
      }
      #cardStealScreen .card canvas,
      #cardSelectionScreen .card canvas {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }
      #infoButton {
        position: absolute;
        text-transform: lowercase;
        top: 480px;
        right: 20px;
        width: 25px;
        height: 25px;
        background: #31ff83;
        color: black;
        border: 2px solid #ffffff;
        border-radius: 50%;
        display: none;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        font-size: medium;
        font-weight: bold;
        font-family: "Courier New", Courier, monospace;
        z-index: 10;
        pointer-events: auto;
        transition: transform 0.2s;
      }
      #infoButton:hover {
        transform: scale(1.05);
        border: #000000 2px solid;
      }
      .canvas-score-timer {
        font-family: "Bangers", sans-serif;
        font-size: 20px; /* Reduced from 24px */
        font-weight: bold;
        color: #ffffff;
        text-align: center;
        text-shadow: 0 0 2px rgba(0, 0, 0, 0.7);
      }
      .canvas-indicator-label {
        font-family: "Bangers", sans-serif;
        font-size: 20px;
        font-weight: bold;
        text-align: center;
        text-shadow: 0 0 2px rgba(0, 0, 0, 0.7);
      }
      .canvas-indicator-number {
        font-family: "Bangers", sans-serif;
        font-size: 56px;
        font-weight: bold;
        text-align: center;
        text-shadow: 0 0 2px rgba(0, 0, 0, 0.7);
      }
      .canvas-start-message {
        font-family: "Bangers", sans-serif;
        font-size: 30px;
        font-weight: bold;
        color: #000000;
        text-align: center;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
      }
      .canvas-game-over-result {
        font-family: "Bangers", sans-serif;
        font-size: 36px;
        font-weight: bold;
        color: #ffffff;
        text-align: center;
      }
      .canvas-level-screen {
        font-family: "Bangers", sans-serif;
        font-weight: bold;
        text-align: center;
        text-shadow: 0 0 2px rgba(0, 0, 0, 0.7);
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <div id="tutorial">
        <h1>Triple Triad Meme</h1>
        <p>Each card has diamond values that mean the value of each side.</p>
        <p>Flip rival cards by placing one with a higher value next to it.</p>
        <p>The one with the most cards at the end of the game wins.</p>
        <button id="rulesButton" onclick="openRulesModal()">Read Rules</button>
        <button id="startButton" onclick="startGame()">Start</button>
      </div>
      <div id="rulesModal">
        <div class="modal-content">
          <h2>Game Rules</h2>
          <p>
            The rules apply beyond the normal functioning of the cards, only at
            certain levels.
          </p>
          <p>
            <strong class="rule-name">Equal:</strong> If a card is placed with
            two or more edges whose values equal those of adjacent cards (own or
            opponent's), the opponent's adjacent cards will be turned over.
          </p>
          <p>
            <strong class="rule-name">Sum:</strong> If a card is placed with two
            or more edges whose sums with adjacent cards' values (own or
            opponent's) are equal, the opponent's adjacent cards will be turned
            over.
          </p>
          <p>
            <strong class="rule-name">Chain:</strong> If Sum or Equal flips two
            or more cards, those cards can flip adjacent opponent cards if their
            values are higher, but only once (no further chaining).
          </p>
          <p>
            <strong class="rule-name">Open:</strong> The cards to be used are
            visible from the beginning.
          </p>
          <button onclick="closeRulesModal()">Close</button>
        </div>
      </div>
      <div id="cardStealScreen" style="display: none">
        <h1>Steal a Card</h1>
        <p>
          Select one card from your opponent's hand to add to your collection
        </p>
        <div class="card-container" id="stealCardContainer"></div>
      </div>
      <div id="cardSelectionScreen" style="display: none">
        <h1>Select Your Hand</h1>
        <p>Choose 5 cards from your collection</p>
        <div class="card-container" id="selectCardContainer"></div>
        <button id="confirmButton" disabled>Confirm</button>
      </div>
      <div id="infoButton">i</div>
      <audio id="backgroundMusic" loop>
        <source src="" type="audio/mpeg" />
      </audio>
      <audio id="flipSound">
        <source
          src="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/flipcard-bJDvwWtrcVtiVAIubenJxDbVBd1CXY.mp3?qmdN"
          type="audio/mpeg"
        />
      </audio>
    </div>
    <script>
      const musicTracks = [
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/theme2-9nRqF4nKYQLx8Ql6Q2PnUeD3nBWAfv.mp3?upIr",
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/theme1-nSdF8QAYRzvgYueeLjNYRLfTndyHyK.mp3?TAh4",
      ];
      let currentTrackIndex = 0;
      const backgroundMusic = document.getElementById("backgroundMusic");

      function playNextTrack() {
        currentTrackIndex = (currentTrackIndex + 1) % musicTracks.length;
        backgroundMusic.src = musicTracks[currentTrackIndex];
        backgroundMusic
          .play()
          .catch((e) => console.error("Music play error:", e));
      }

      backgroundMusic.addEventListener("ended", playNextTrack);
      backgroundMusic.volume = 0.2; // Softer background music
      document.getElementById("flipSound").volume = 0.5;

      function setMuted(isMuted) {
        backgroundMusic.muted = isMuted;
        document.getElementById("flipSound").muted = isMuted;
      }

      window.FarcadeSDK.on("toggle_mute", (data) => {
        setMuted(data.isMuted);
      });

      function resetGame() {
        level = 1;
        playerCardBank = [];
        playerHand = [];
        aiHand = [];
        initialAiHand = [];
        totalScore = 0;
        playerScore = 5;
        aiScore = 5;
        opponentName = "";
        activeRules = [];
        gameOver = false;
        initGame();
      }

      window.FarcadeSDK.on("play_again", () => {
        resetGame();
      });

      function startGame() {
        tutorialVisible = false;
        document.getElementById("tutorial").style.display = "none";
        backgroundMusic.src = musicTracks[currentTrackIndex];
        backgroundMusic
          .play()
          .catch((e) => console.error("Music play error:", e));
        initGame();
        drawRequested = true;
        requestAnimationFrame(gameLoop); // Explicitly start the game loop
      }

      function openRulesModal() {
        document.getElementById("rulesModal").style.display = "flex";
      }

      function closeRulesModal() {
        document.getElementById("rulesModal").style.display = "none";
      }

      document
        .getElementById("infoButton")
        .addEventListener("click", openRulesModal);

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      let scaleFactor = 1;
      let board = Array(9).fill(null);
      let playerHand = [];
      let aiHand = [];
      let initialAiHand = [];
      let playerCardBank = [];
      let currentPlayer = "player";
      let playerScore = 5;
      let aiScore = 5;
      let totalScore = 0;
      let selectedCard = null;
      let draggingCard = null;
      let hoveredCard = null;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let gameOver = false;
      let tutorialVisible = true;
      let level = 1;
      let opponentName = "";
      let gameTime = 0;
      let timerInterval;
      let flippingCards = [];
      let highlightedCell = -1;
      let startMessage = { text: "", opacity: 1, time: 0 };
      let ruleMessage = { text: "", opacity: 1, time: 0 };
      let levelScreenVisible = true;
      let levelScreenStartTime = 0;
      let levelScreenShown = false;
      let cardStealScreenVisible = false;
      let cardSelectionScreenVisible = false;
      let drawRequested = false;
      let activeRules = [];

      const opponentNames = [
        "Warlord Thorne",
        "High Mage Elzareth",
        "Shadowblade Kael",
        "Sir Dregan the Grim",
        "Druidess Nyla",
        "Baron Mordrak",
        "Archknight Varyn",
        "Hexcaller Sythra",
        "Ranger Thistlefang",
        "Dark Seer Malvok",
      ];
      const boardWidthPx = 360;
      const boardHeightPx = 504;
      const cardWidthPx = 120;
      const cardHeightPx = 168;
      const handCardWidthPx = 90;
      const handCardHeightPx = 126;
      const aiCardWidthPx = 90;
      const aiCardHeightPx = 126;
      const aiHandY = 50;
      const boardTopMargin = 10;
      const playerHandOffset = 0;

      const cardDatabase = [
        {
          id: 1,
          tier: "S",
          values: [10, 9, 5, 7],
          element: "Poison",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta1-Q3U90gcLoB6BToQRLeggVDuRHz8wLY.png?qGoq",
        },
        {
          id: 2,
          tier: "S",
          values: [5, 6, 10, 10],
          element: "Blue Fire",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta2-yD57XXsxEnIgEAiDPO6FKyv2PM2ycf.png?3OpE",
        },
        {
          id: 3,
          tier: "S",
          values: [7, 6, 8, 10],
          element: "Spirit",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta3-BmhLIAAK90aKiJVqEhlrbHAJxZV32x.png?P54r",
        },
        {
          id: 4,
          tier: "S",
          values: [8, 10, 7, 6],
          element: "Void",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta4-St0lH9UNG0trx7oirVJjXn8LoBtEoq.png?AyCQ",
        },
        {
          id: 5,
          tier: "S",
          values: [8, 9, 7, 8],
          element: "Thunder",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta5-SR9pkVoo6NKMaMgBwIXJXzOub2lh5v.png?waZW",
        },
        {
          id: 6,
          tier: "A",
          values: [9, 7, 4, 7],
          element: "Thunder",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta6-yBatSsTHsA70TQHYOjki5u5jGPyG5l.png?0U4G",
        },
        {
          id: 7,
          tier: "A",
          values: [3, 9, 9, 6],
          element: "Frost",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta7-ZdlImD9gFakrydTrmdFAJi5CdISccz.png?ubar",
        },
        {
          id: 8,
          tier: "A",
          values: [7, 4, 7, 9],
          element: "Gold",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta8-Bv2u19garV23qelvvqawxtPVz1BZfL.png?7A4P",
        },
        {
          id: 9,
          tier: "A",
          values: [7, 10, 5, 5],
          element: "Gold",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta9-Yc47tgnyZ6ZPt9ks4xUPp5a1nbFptg.png?cDXH",
        },
        {
          id: 10,
          tier: "A",
          values: [7, 8, 6, 7],
          element: "Void",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta10-cWVD0dj0e35YkkdGeAZ5n0qJ5Yc6vC.png?NQQP",
        },
        {
          id: 11,
          tier: "B",
          values: [8, 5, 3, 7],
          element: "Blue Fire",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta11-jF6kHFh7VUxNi9XtUVngK5lNqKiWiB.png?wEgs",
        },
        {
          id: 12,
          tier: "B",
          values: [4, 7, 9, 3],
          element: "Spirit",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta12-GV8XMJbQgrpNl02ROtblCnF4mtS8zZ.png?m7kD",
        },
        {
          id: 13,
          tier: "B",
          values: [6, 3, 6, 8],
          element: "Frost",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta13-4lxa05zK0F4zLULrLfkOobSjNjc4pL.png?Hgl5",
        },
        {
          id: 14,
          tier: "B",
          values: [6, 9, 5, 3],
          element: "Void",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta14-nM0tAwZvs5p1CPgHwiAPIsOcXlPEgG.png?oveZ",
        },
        {
          id: 15,
          tier: "B",
          values: [5, 8, 6, 5],
          element: "Poison",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta15-4NLly9NxyiaoXrTuT6CzyNMQs3UaGC.png?6G0R",
        },
        {
          id: 16,
          tier: "C",
          values: [7, 3, 2, 8],
          element: "No element",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta16-g7CeXJ4pIJHrI0ByiMFZpzKF3xnWZo.png?Wifu",
        },
        {
          id: 17,
          tier: "C",
          values: [3, 5, 7, 4],
          element: "No element",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta17-yoOOYRIZw9hukaISCrYiY8SIvRwbNQ.png?xtfZ",
        },
        {
          id: 18,
          tier: "C",
          values: [2, 3, 6, 8],
          element: "No element",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta18-w9WxI6rOLxONtQl9sEU6ICtH3L4Yid.png?qPJm",
        },
        {
          id: 19,
          tier: "C",
          values: [5, 9, 1, 2],
          element: "No element",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta19-Rf7KpdnadNwybvIISmRCuzEAfk2JL1.png?o6w7",
        },
        {
          id: 20,
          tier: "C",
          values: [7, 5, 1, 4],
          element: "No element",
          image:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/carta20-tqineyrVlV3QVmoDjSd4VH9t716mVE.png?uy1w",
        },
      ];

      const cardImages = cardDatabase.map((card) => {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = card.image;
        return img;
      });

      const boardImage = new Image();
      boardImage.crossOrigin = "Anonymous";
      boardImage.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/Dise%C3%B1o%20sin%20t%C3%ADtulo%20%2834%29-j6kMu2qRF78WNzk57s2jEWg74L8EBB.png?4wh8";

      const backImage = new Image();
      backImage.crossOrigin = "Anonymous";
      backImage.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/wknmNHLS2O2r/Game%20On%20%282%29-KcOBLLi6T6w4JKl3yIaOCWawc7RaZc.png?rOfA";

      function preloadImages(images, callback) {
        let loaded = 0;
        const total = images.length;
        images.forEach((img) => {
          img.onload = () => {
            loaded++;
            if (loaded === total) {
              callback();
              requestAnimationFrame(gameLoop); // Start game loop after preload
            }
          };
          img.onerror = () => {
            console.error(`Error loading image: ${img.src}`);
            loaded++;
            if (loaded === total) {
              callback();
              requestAnimationFrame(gameLoop); // Start game loop even if some images fail
            }
          };
        });
      }

      function resizeCanvas() {
        const container = document.getElementById("gameContainer");
        const width = Math.min(container.clientWidth, 500);
        const height = Math.min(container.clientHeight, 1000);
        scaleFactor = width / 500;
        canvas.width = width;
        canvas.height = height;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        console.log(
          `Canvas resized: width=${width}, height=${height}, scaleFactor=${scaleFactor}`
        );
        drawRequested = true;
      }

      function getTierDistribution(level) {
        const playerDist = { C: 3, B: 2 };
        let aiDist;
        switch (level) {
          case 1:
            aiDist = { C: 4, A: 1 };
            break;
          case 2:
            aiDist = { C: 2, B: 2, A: 1 };
            break;
          case 3:
            aiDist = { B: 3, A: 2 };
            break;
          case 4:
            aiDist = { B: 3, A: 1, S: 1 };
            break;
          case 5:
            aiDist = { A: 3, S: 2 };
            break;
          case 6:
            aiDist = { A: 2, S: 3 };
            break;
          case 7:
            aiDist = { A: 1, S: 4 };
            break;
          default:
            aiDist = { S: 5 }; // Level 8 and beyond
        }
        return { player: playerDist, ai: aiDist };
      }

      function generateHand(distribution, owner, availableCards) {
        const hand = [];
        const tiers = Object.keys(distribution);
        let tempCards = [...availableCards];
        for (const tier of tiers) {
          const count = distribution[tier] || 0;
          const tierCards = tempCards.filter((card) => card.tier === tier);
          for (let i = 0; i < count && tierCards.length > 0; i++) {
            const index = Math.floor(Math.random() * tierCards.length);
            const card = {
              ...tierCards[index],
              owner,
              imageIndex: cardDatabase.findIndex(
                (c) => c.id === tierCards[index].id
              ),
            };
            hand.push(card);
            tempCards = tempCards.filter((c) => c.id !== card.id);
            tierCards.splice(index, 1);
          }
        }
        while (hand.length < 5 && tempCards.length > 0) {
          const index = Math.floor(Math.random() * tempCards.length);
          const card = {
            ...tempCards[index],
            owner,
            imageIndex: cardDatabase.findIndex(
              (c) => c.id === tempCards[index].id
            ),
          };
          hand.push(card);
          tempCards = tempCards.filter((c) => c.id !== card.id);
        }
        return hand.slice(0, 5);
      }

      function getLevelRules(level) {
        if (level === 1) return ["Open"];
        if (level === 2) return ["Open", "Sum"];
        if (level === 3) return ["Equal"];
        if (level === 4) return ["Sum", "Chain"];
        if (level === 5) return ["Sum"];
        if (level === 6) return ["Equal", "Chain"];
        if (level === 7) return ["Equal"];
        if (level === 8) return ["Sum", "Chain"];
        if (level === 9) return ["Sum"];
        if (level === 10) return ["Equal", "Chain"];
        const cycle = ["Sum", "Equal,Chain", "Sum"];
        const ruleIndex = (level - 11) % 3;
        return cycle[ruleIndex].split(",");
      }

      function drawCardValues(canvas, card) {
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold 14px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const offsetX = 18;
        const offsetY = 18;
        const spacing = 7;
        ctx.fillStyle = "#ffffff";
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 3;
        ctx.strokeText(
          card.values[0] === 10 ? "A" : card.values[0],
          offsetX,
          offsetY - spacing
        );
        ctx.fillText(
          card.values[0] === 10 ? "A" : card.values[0],
          offsetX,
          offsetY - spacing
        );
        ctx.strokeText(
          card.values[1] === 10 ? "A" : card.values[1],
          offsetX + spacing,
          offsetY
        );
        ctx.fillText(
          card.values[1] === 10 ? "A" : card.values[1],
          offsetX + spacing,
          offsetY
        );
        ctx.strokeText(
          card.values[2] === 10 ? "A" : card.values[2],
          offsetX,
          offsetY + spacing
        );
        ctx.fillText(
          card.values[2] === 10 ? "A" : card.values[2],
          offsetX,
          offsetY + spacing
        );
        ctx.strokeText(
          card.values[3] === 10 ? "A" : card.values[3],
          offsetX - spacing,
          offsetY
        );
        ctx.fillText(
          card.values[3] === 10 ? "A" : card.values[3],
          offsetX - spacing,
          offsetY
        );
      }

      function initGame() {
        playerScore = 5;
        aiScore = 5;
        board = Array(9).fill(null);
        playerHand = [];
        aiHand = [];
        initialAiHand = [];
        flippingCards = [];
        gameOver = false;
        gameTime = 0;
        selectedCard = null;
        draggingCard = null;
        hoveredCard = null;
        highlightedCell = -1;
        startMessage = { text: "", opacity: 0, time: 0 };
        ruleMessage = { text: "", opacity: 0, time: 0 };
        levelScreenVisible = true;
        levelScreenStartTime = Date.now();
        levelScreenShown = false;
        cardStealScreenVisible = false;
        cardSelectionScreenVisible = false;

        opponentName = opponentNames[(level - 1) % opponentNames.length];
        activeRules = getLevelRules(level);

        if (playerCardBank.length === 0) {
          const initialCards = cardDatabase.filter((card) =>
            ["B", "C"].includes(card.tier)
          );
          let tempCards = [...initialCards];
          for (let i = 0; i < 5 && tempCards.length > 0; i++) {
            const index = Math.floor(Math.random() * tempCards.length);
            const card = {
              ...tempCards[index],
              owner: "player",
              imageIndex: cardDatabase.findIndex(
                (c) => c.id === tempCards[index].id
              ),
            };
            playerCardBank.push(card);
            tempCards.splice(index, 1);
          }
        }

        const distributions = getTierDistribution(level);
        initialAiHand = generateHand(distributions.ai, "ai", cardDatabase);
        aiHand = [...initialAiHand];
        if (level === 1) {
          const lowTierCards = playerCardBank.filter((card) =>
            ["B", "C"].includes(card.tier)
          );
          playerHand = generateHand({ C: 3, B: 2 }, "player", lowTierCards);
        }

        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
          gameTime++;
          drawRequested = true;
        }, 1000);

        if (level > 1) {
          setTimeout(() => {
            levelScreenVisible = false;
            showCardSelectionScreen();
          }, 3000);
        } else {
          setTimeout(() => {
            levelScreenVisible = false;
            currentPlayer = Math.random() < 0.5 ? "player" : "ai";
            startMessage = {
              text:
                currentPlayer === "player" ? "Player Starts!" : "AI Starts!",
              opacity: 1,
              time: Date.now(),
            };
            if (currentPlayer === "ai") setTimeout(aiMove, 1000);
            drawRequested = true;
          }, 3000);
        }
        drawRequested = true;
      }

      function showCardStealScreen() {
        cardStealScreenVisible = true;
        document.getElementById("cardStealScreen").style.display = "flex";
        document.getElementById("infoButton").style.display = "none";
        const container = document.getElementById("stealCardContainer");
        container.innerHTML = "";
        initialAiHand.forEach((card, index) => {
          const cardElement = document.createElement("div");
          cardElement.className = "card";
          cardElement.style.backgroundImage = `url(${card.image})`;
          cardElement.style.backgroundSize = "cover";
          cardElement.dataset.index = index;

          const canvas = document.createElement("canvas");
          canvas.width = 90;
          canvas.height = 126;
          drawCardValues(canvas, card);
          cardElement.appendChild(canvas);

          cardElement.addEventListener("click", () => {
            container
              .querySelectorAll(".card")
              .forEach((el) => el.classList.remove("selected"));
            cardElement.classList.add("selected");
            playerCardBank.push({
              ...card,
              owner: "player",
              imageIndex: card.imageIndex,
            });
            document.getElementById("cardStealScreen").style.display = "none";
            cardStealScreenVisible = false;
            level++;
            initGame();
          });
          container.appendChild(cardElement);
        });
        drawRequested = true;
      }

      function showCardSelectionScreen() {
        cardSelectionScreenVisible = true;
        document.getElementById("cardSelectionScreen").style.display = "flex";
        document.getElementById("infoButton").style.display = "none";
        const container = document.getElementById("selectCardContainer");
        const confirmButton = document.getElementById("confirmButton");
        container.innerHTML = "";

        const cardsPerPage = 6;
        let currentPage = 0;
        const selectedCards = [];

        function renderCards() {
          container.innerHTML = "";
          const start = currentPage * cardsPerPage;
          const end = Math.min(start + cardsPerPage, playerCardBank.length);
          const currentCards = playerCardBank.slice(start, end);

          const cardContainer = document.createElement("div");
          cardContainer.className = "card-container";
          currentCards.forEach((card, index) => {
            const globalIndex = start + index;
            const cardElement = document.createElement("div");
            cardElement.className = "card";
            cardElement.style.backgroundImage = `url(${card.image})`;
            cardElement.style.backgroundSize = "cover";
            cardElement.dataset.index = globalIndex;

            const canvas = document.createElement("canvas");
            canvas.width = 90;
            canvas.height = 126;
            drawCardValues(canvas, card);
            cardElement.appendChild(canvas);

            cardElement.addEventListener("click", () => {
              if (cardElement.classList.contains("selected")) {
                cardElement.classList.remove("selected");
                const idx = selectedCards.indexOf(globalIndex);
                if (idx !== -1) selectedCards.splice(idx, 1);
              } else if (selectedCards.length < 5) {
                cardElement.classList.add("selected");
                selectedCards.push(globalIndex);
              }
              confirmButton.disabled = selectedCards.length !== 5;
            });
            cardContainer.appendChild(cardElement);

            if (selectedCards.includes(globalIndex)) {
              cardElement.classList.add("selected");
            }
          });
          container.appendChild(cardContainer);

          const paginationContainer = document.createElement("div");
          paginationContainer.className = "pagination-container";

          const prevButton = document.createElement("button");
          prevButton.className = "pagination-button";
          prevButton.textContent = "←";
          prevButton.disabled = currentPage === 0;
          prevButton.addEventListener("click", () => {
            if (currentPage > 0) {
              currentPage--;
              renderCards();
            }
          });

          const nextButton = document.createElement("button");
          nextButton.className = "pagination-button";
          nextButton.textContent = "→";
          nextButton.disabled = end >= playerCardBank.length;
          nextButton.addEventListener("click", () => {
            if (end < playerCardBank.length) {
              currentPage++;
              renderCards();
            }
          });

          paginationContainer.appendChild(prevButton);
          paginationContainer.appendChild(nextButton);
          container.appendChild(paginationContainer);
        }

        renderCards();
        confirmButton.disabled = true;
        confirmButton.onclick = () => {
          if (selectedCards.length === 5) {
            playerHand = selectedCards.map((idx) => ({
              ...playerCardBank[idx],
              owner: "player",
              imageIndex: playerCardBank[idx].imageIndex,
            }));
            document.getElementById("cardSelectionScreen").style.display =
              "none";
            cardSelectionScreenVisible = false;
            const distributions = getTierDistribution(level);
            initialAiHand = generateHand(distributions.ai, "ai", cardDatabase);
            aiHand = [...initialAiHand];
            currentPlayer = Math.random() < 0.5 ? "player" : "ai";
            startMessage = {
              text:
                currentPlayer === "player" ? "Player Starts!" : "AI Starts!",
              opacity: 1,
              time: Date.now(),
            };
            if (currentPlayer === "ai") setTimeout(aiMove, 1000);
            drawRequested = true;
          }
        };
        drawRequested = true;
      }
      preloadImages([...cardImages, boardImage, backImage], () => {
        resizeCanvas();
        window.FarcadeSDK.singlePlayer.actions.ready();
      });

      function drawCard(
        x,
        y,
        card,
        width,
        height,
        isSelected = false,
        isDragging = false,
        isBack = false,
        oldOwner = null,
        isHovered = false,
        flipProgress = null
      ) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scaleFactor, scaleFactor);

        ctx.beginPath();
        ctx.rect(0, 0, width, height);
        ctx.clip();

        if (isBack) {
          ctx.fillStyle = "#333333";
          ctx.fillRect(0, 0, width, height);
          if (backImage.complete && backImage.naturalWidth) {
            ctx.drawImage(backImage, 0, 0, width, height);
          }
        } else {
          let fillStyle;
          if (flipProgress !== null && oldOwner) {
            const playerColor = { r: 214, g: 60, b: 225 }; // #D63CE1
            const aiColor = { r: 49, g: 255, b: 131 }; // #31ff83
            const startColor = oldOwner === "player" ? playerColor : aiColor;
            const endColor = card.owner === "player" ? playerColor : aiColor;
            const r = Math.round(
              startColor.r + (endColor.r - startColor.r) * flipProgress
            );
            const g = Math.round(
              startColor.g + (endColor.g - startColor.g) * flipProgress
            );
            const b = Math.round(
              startColor.b + (endColor.b - startColor.b) * flipProgress
            );
            fillStyle = `rgb(${r}, ${g}, ${b})`;
          } else {
            fillStyle = card.owner === "player" ? "#D63CE1" : "#31ff83";
          }
          ctx.fillStyle = fillStyle;
          ctx.fillRect(0, 0, width, height);

          ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
          ctx.shadowBlur = 4;
          ctx.shadowOffsetX = 2;
          ctx.shadowOffsetY = 2;
          ctx.fillRect(0, 0, width, height);
          ctx.shadowColor = "transparent";
        }

        if (!isBack) {
          const cardImage = cardImages[card.imageIndex] || new Image();
          if (cardImage.complete && cardImage.naturalWidth) {
            ctx.drawImage(cardImage, 0, 0, width, height);
          } else {
            ctx.fillStyle = "#666666";
            ctx.fillRect(0, 0, width, height);
          }
        }

        if (!isBack) {
          ctx.font = `bold 18px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          const offsetX = 22;
          const offsetY = 22;
          const spacing = 10;

          ctx.fillStyle = "#ffffff";
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 2;
          ctx.strokeText(
            card.values[0] === 10 ? "A" : card.values[0],
            offsetX,
            offsetY - spacing
          );
          ctx.fillText(
            card.values[0] === 10 ? "A" : card.values[0],
            offsetX,
            offsetY - spacing
          );
          ctx.strokeText(
            card.values[1] === 10 ? "A" : card.values[1],
            offsetX + spacing,
            offsetY
          );
          ctx.fillText(
            card.values[1] === 10 ? "A" : card.values[1],
            offsetX + spacing,
            offsetY
          );
          ctx.strokeText(
            card.values[2] === 10 ? "A" : card.values[2],
            offsetX,
            offsetY + spacing
          );
          ctx.fillText(
            card.values[2] === 10 ? "A" : card.values[2],
            offsetX,
            offsetY + spacing
          );
          ctx.strokeText(
            card.values[3] === 10 ? "A" : card.values[3],
            offsetX - spacing,
            offsetY
          );
          ctx.fillText(
            card.values[3] === 10 ? "A" : card.values[3],
            offsetX - spacing,
            offsetY
          );
        }

        ctx.restore();
      }
      function checkCapture(index, card) {
        const row = Math.floor(index / 3);
        const col = index % 3;
        let captures = [];
        let specialCaptures = [];
        let chainCaptures = [];

        if (
          row > 0 &&
          board[index - 3] &&
          board[index - 3].owner !== card.owner
        ) {
          if (card.values[0] > board[index - 3].values[2]) {
            captures.push(index - 3);
          }
        }
        if (
          col < 2 &&
          board[index + 1] &&
          board[index + 1].owner !== card.owner
        ) {
          if (card.values[1] > board[index + 1].values[3]) {
            captures.push(index + 1);
          }
        }
        if (
          row < 2 &&
          board[index + 3] &&
          board[index + 3].owner !== card.owner
        ) {
          if (card.values[2] > board[index + 3].values[0]) {
            captures.push(index + 3);
          }
        }
        if (
          col > 0 &&
          board[index - 1] &&
          board[index - 1].owner !== card.owner
        ) {
          if (card.values[3] > board[index - 1].values[1]) {
            captures.push(index - 1);
          }
        }

        if (activeRules.includes("Equal")) {
          const equalMatches = [];
          if (row > 0 && board[index - 3]) {
            if (card.values[0] === board[index - 3].values[2]) {
              equalMatches.push({
                index: index - 3,
                owner: board[index - 3].owner,
              });
            }
          }
          if (col < 2 && board[index + 1]) {
            if (card.values[1] === board[index + 1].values[3]) {
              equalMatches.push({
                index: index + 1,
                owner: board[index + 1].owner,
              });
            }
          }
          if (row < 2 && board[index + 3]) {
            if (card.values[2] === board[index + 3].values[0]) {
              equalMatches.push({
                index: index + 3,
                owner: board[index + 3].owner,
              });
            }
          }
          if (col > 0 && board[index - 1]) {
            if (card.values[3] === board[index - 1].values[1]) {
              equalMatches.push({
                index: index - 1,
                owner: board[index - 1].owner,
              });
            }
          }
          if (equalMatches.length >= 2) {
            const opponentCaptures = equalMatches
              .filter((m) => m.owner !== card.owner)
              .map((m) => m.index);
            specialCaptures.push(...opponentCaptures);
            captures.push(...opponentCaptures);
            if (opponentCaptures.length > 0) {
              ruleMessage = {
                text: "EQUAL Applied!",
                opacity: 1,
                time: Date.now(),
              };
            }
          }
        }

        if (activeRules.includes("Sum")) {
          const sumMatches = [];
          if (row > 0 && board[index - 3]) {
            sumMatches.push({
              index: index - 3,
              sum: card.values[0] + board[index - 3].values[2],
              owner: board[index - 3].owner,
            });
          }
          if (col < 2 && board[index + 1]) {
            sumMatches.push({
              index: index + 1,
              sum: card.values[1] + board[index + 1].values[3],
              owner: board[index + 1].owner,
            });
          }
          if (row < 2 && board[index + 3]) {
            sumMatches.push({
              index: index + 3,
              sum: card.values[2] + board[index + 3].values[0],
              owner: board[index + 3].owner,
            });
          }
          if (col > 0 && board[index - 1]) {
            sumMatches.push({
              index: index - 1,
              sum: card.values[3] + board[index - 1].values[1],
              owner: board[index - 1].owner,
            });
          }
          const sums = sumMatches.map((m) => m.sum);
          const commonSum = sums.find((sum, i) => sums.indexOf(sum) !== i);
          if (
            commonSum &&
            sumMatches.filter((m) => m.sum === commonSum).length >= 2
          ) {
            const opponentCaptures = sumMatches
              .filter((m) => m.sum === commonSum && m.owner !== card.owner)
              .map((m) => m.index);
            specialCaptures.push(...opponentCaptures);
            captures.push(...opponentCaptures);
            if (opponentCaptures.length > 0) {
              ruleMessage = {
                text: "SUM Applied!",
                opacity: 1,
                time: Date.now(),
              };
            }
          }
        }

        captures = [...new Set(captures)];
        chainCaptures.push(...captures);

        if (activeRules.includes("Chain") && specialCaptures.length >= 2) {
          specialCaptures.forEach((chainIndex) => {
            const chainRow = Math.floor(chainIndex / 3);
            const chainCol = chainIndex % 3;
            const chainCard = board[chainIndex];
            const newOwner = card.owner;

            let newCaptures = [];
            if (
              chainRow > 0 &&
              board[chainIndex - 3] &&
              board[chainIndex - 3].owner !== newOwner
            ) {
              if (chainCard.values[0] > board[chainIndex - 3].values[2]) {
                newCaptures.push(chainIndex - 3);
              }
            }
            if (
              chainCol < 2 &&
              board[chainIndex + 1] &&
              board[chainIndex + 1].owner !== newOwner
            ) {
              if (chainCard.values[1] > board[chainIndex + 1].values[3]) {
                newCaptures.push(chainIndex + 1);
              }
            }
            if (
              chainRow < 2 &&
              board[chainIndex + 3] &&
              board[chainIndex + 3].owner !== newOwner
            ) {
              if (chainCard.values[2] > board[chainIndex + 3].values[0]) {
                newCaptures.push(chainIndex + 3);
              }
            }
            if (
              chainCol > 0 &&
              board[chainIndex - 1] &&
              board[chainIndex - 1].owner !== newOwner
            ) {
              if (chainCard.values[3] > board[chainIndex - 1].values[1]) {
                newCaptures.push(chainIndex - 1);
              }
            }

            newCaptures = [...new Set(newCaptures)].filter(
              (idx) => !chainCaptures.includes(idx)
            );
            chainCaptures.push(...newCaptures);
          });
          if (chainCaptures.length > captures.length) {
            ruleMessage = {
              text: "CHAIN Applied!",
              opacity: 1,
              time: Date.now(),
            };
          }
        }

        chainCaptures.forEach((i) => {
          const oldOwner = board[i].owner;
          board[i].owner = card.owner;
          flippingCards.push({ index: i, progress: 0, ease: 0 });
          if (oldOwner === "player" && card.owner === "ai") {
            playerScore--;
            aiScore++;
          } else if (oldOwner === "ai" && card.owner === "player") {
            aiScore--;
            playerScore++;
          }
          const flipSound = document.getElementById("flipSound");
          if (flipSound && !backgroundMusic.muted) {
            flipSound.currentTime = 0;
            flipSound.play();
          }
          try {
            window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          } catch (e) {
            console.warn("Haptic feedback failed:", e);
          }
        });
      }

      function aiMove() {
        if (currentPlayer !== "ai" || gameOver) return;
        const emptyCells = board
          .map((cell, i) => (cell ? -1 : i))
          .filter((i) => i >= 0);
        if (emptyCells.length === 0 || aiHand.length === 0) {
          endGame();
          return;
        }

        let bestMove = null;
        let bestScore = -1;
        emptyCells.forEach((cell) => {
          aiHand.forEach((card, cardIndex) => {
            const tempBoard = [...board];
            tempBoard[cell] = { ...card, owner: "ai" };
            let captures = [];
            let specialCaptures = [];
            const row = Math.floor(cell / 3);
            const col = cell % 3;

            if (
              row > 0 &&
              tempBoard[cell - 3] &&
              tempBoard[cell - 3].owner === "player"
            ) {
              if (card.values[0] > tempBoard[cell - 3].values[2])
                captures.push(cell - 3);
            }
            if (
              col < 2 &&
              tempBoard[cell + 1] &&
              tempBoard[cell + 1].owner === "player"
            ) {
              if (card.values[1] > tempBoard[cell + 1].values[3])
                captures.push(cell + 1);
            }
            if (
              row < 2 &&
              tempBoard[cell + 3] &&
              tempBoard[cell + 3].owner === "player"
            ) {
              if (card.values[2] > tempBoard[cell + 3].values[0])
                captures.push(cell + 3);
            }
            if (
              col > 0 &&
              tempBoard[cell - 1] &&
              tempBoard[cell - 1].owner === "player"
            ) {
              if (card.values[3] > tempBoard[cell - 1].values[1])
                captures.push(cell - 1);
            }

            if (activeRules.includes("Equal")) {
              const equalMatches = [];
              if (row > 0 && tempBoard[cell - 3]) {
                if (card.values[0] === tempBoard[cell - 3].values[2]) {
                  equalMatches.push({
                    index: cell - 3,
                    owner: tempBoard[cell - 3].owner,
                  });
                }
              }
              if (col < 2 && tempBoard[cell + 1]) {
                if (card.values[1] === tempBoard[cell + 1].values[3]) {
                  equalMatches.push({
                    index: cell + 1,
                    owner: tempBoard[cell + 1].owner,
                  });
                }
              }
              if (row < 2 && tempBoard[cell + 3]) {
                if (card.values[2] === tempBoard[cell + 3].values[0]) {
                  equalMatches.push({
                    index: cell + 3,
                    owner: tempBoard[cell + 3].owner,
                  });
                }
              }
              if (col > 0 && tempBoard[cell - 1]) {
                if (card.values[3] === tempBoard[cell - 1].values[1]) {
                  equalMatches.push({
                    index: cell - 1,
                    owner: tempBoard[cell - 1].owner,
                  });
                }
              }
              if (equalMatches.length >= 2) {
                const opponentCaptures = equalMatches
                  .filter((m) => m.owner === "player")
                  .map((m) => m.index);
                specialCaptures.push(...opponentCaptures);
                captures.push(...opponentCaptures);
              }
            }

            if (activeRules.includes("Sum")) {
              const sumMatches = [];
              if (row > 0 && tempBoard[cell - 3]) {
                sumMatches.push({
                  index: cell - 3,
                  sum: card.values[0] + tempBoard[cell - 3].values[2],
                  owner: tempBoard[cell - 3].owner,
                });
              }
              if (col < 2 && tempBoard[cell + 1]) {
                sumMatches.push({
                  index: cell + 1,
                  sum: card.values[1] + tempBoard[cell + 1].values[3],
                  owner: tempBoard[cell + 1].owner,
                });
              }
              if (row < 2 && tempBoard[cell + 3]) {
                sumMatches.push({
                  index: cell + 3,
                  sum: card.values[2] + tempBoard[cell + 3].values[0],
                  owner: tempBoard[cell + 3].owner,
                });
              }
              if (col > 0 && tempBoard[cell - 1]) {
                sumMatches.push({
                  index: cell - 1,
                  sum: card.values[3] + tempBoard[cell - 1].values[1],
                  owner: tempBoard[cell - 1].owner,
                });
              }
              const sums = sumMatches.map((m) => m.sum);
              const commonSum = sums.find((sum, i) => sums.indexOf(sum) !== i);
              if (
                commonSum &&
                sumMatches.filter((m) => m.sum === commonSum).length >= 2
              ) {
                const opponentCaptures = sumMatches
                  .filter((m) => m.sum === commonSum && m.owner === "player")
                  .map((m) => m.index);
                specialCaptures.push(...opponentCaptures);
                captures.push(...opponentCaptures);
              }
            }

            if (activeRules.includes("Chain") && specialCaptures.length >= 2) {
              specialCaptures.forEach((chainIndex) => {
                const chainRow = Math.floor(chainIndex / 3);
                const chainCol = chainIndex % 3;
                const chainCard = tempBoard[chainIndex] || card;

                let newCaptures = [];
                if (
                  chainRow > 0 &&
                  tempBoard[chainIndex - 3] &&
                  tempBoard[chainIndex - 3].owner === "player"
                ) {
                  if (chainCard.values[0] > tempBoard[chainIndex - 3].values[2])
                    newCaptures.push(chainIndex - 3);
                }
                if (
                  chainCol < 2 &&
                  tempBoard[chainIndex + 1] &&
                  tempBoard[chainIndex + 1].owner === "player"
                ) {
                  if (chainCard.values[1] > tempBoard[chainIndex + 1].values[3])
                    newCaptures.push(chainIndex + 1);
                }
                if (
                  chainRow < 2 &&
                  tempBoard[chainIndex + 3] &&
                  tempBoard[chainIndex + 3].owner === "player"
                ) {
                  if (chainCard.values[2] > tempBoard[chainIndex + 3].values[0])
                    newCaptures.push(chainIndex + 3);
                }
                if (
                  chainCol > 0 &&
                  tempBoard[chainIndex - 1] &&
                  tempBoard[chainIndex - 1].owner === "player"
                ) {
                  if (chainCard.values[3] > tempBoard[chainIndex - 1].values[1])
                    newCaptures.push(chainIndex - 1);
                }

                newCaptures = newCaptures.filter(
                  (idx) => !captures.includes(idx)
                );
                captures.push(...newCaptures);
              });
            }

            const score = captures.length;
            if (score > bestScore) {
              bestScore = score;
              bestMove = { cell, cardIndex };
            }
          });
        });

        if (bestMove) {
          const { cell, cardIndex } = bestMove;
          board[cell] = aiHand[cardIndex];
          checkCapture(cell, board[cell]);
          aiHand.splice(cardIndex, 1);
          currentPlayer = "player";
          if (
            board.every((cell) => cell) ||
            (playerHand.length === 0 && aiHand.length === 0)
          ) {
            endGame();
          }
        }
        drawRequested = true;
      }

      function endGame() {
        gameOver = true;
        clearInterval(timerInterval);
        if (playerScore > aiScore) {
          totalScore += Math.floor(10000 * Math.max(1, 2 - gameTime / 60));
          gameOver = false;
          setTimeout(showCardStealScreen, 2000);
        } else {
          setTimeout(() => {
            if (playerScore === aiScore) {
              gameOver = false;
              initGame(); // Restart same level on draw
            } else {
              try {
                window.FarcadeSDK.singlePlayer.actions.gameOver({
                  score: totalScore,
                });
              } catch (e) {
                console.warn("Game over SDK call failed:", e);
              }
            }
          }, 2000);
        }
        drawRequested = true;
      }
      let dragX = 0;
      let dragY = 0;

      function handleStart(x, y) {
        if (
          tutorialVisible ||
          levelScreenVisible ||
          cardStealScreenVisible ||
          cardSelectionScreenVisible
        )
          return;
        if (gameOver) return;
        if (currentPlayer !== "player") return;

        const boardY =
          aiHandY * scaleFactor +
          aiCardHeightPx * scaleFactor +
          boardTopMargin * scaleFactor;
        const handY = boardY + boardHeightPx * scaleFactor + 20 * scaleFactor;
        const scaledCardWidth = handCardWidthPx * scaleFactor;
        const totalHandWidth = scaledCardWidth * playerHand.length;
        let handX = (canvas.width - totalHandWidth) / 2;
        handX = Math.max(0, Math.min(handX, canvas.width - totalHandWidth));

        if (y > handY && y < handY + handCardHeightPx * scaleFactor) {
          for (let i = playerHand.length - 1; i >= 0; i--) {
            const cardX = handX + i * scaledCardWidth;
            const cardY = handY;
            if (
              x >= cardX &&
              x < cardX + scaledCardWidth &&
              y >= cardY &&
              y < cardY + handCardHeightPx * scaleFactor
            ) {
              draggingCard = i;
              hoveredCard = null;
              dragOffsetX = (-handCardWidthPx / 2) * scaleFactor;
              dragOffsetY = (-handCardHeightPx / 2) * scaleFactor;
              dragX = x;
              dragY = y;
              drawRequested = true;
              break;
            }
          }
        }
      }
      function handleMove(x, y) {
        dragX = x;
        dragY = y;

        const boardY =
          aiHandY * scaleFactor +
          aiCardHeightPx * scaleFactor +
          boardTopMargin * scaleFactor;
        const handY = boardY + boardHeightPx * scaleFactor + 20 * scaleFactor;
        const scaledCardWidth = handCardWidthPx * scaleFactor;
        const totalHandWidth = scaledCardWidth * playerHand.length;
        let handX = (canvas.width - totalHandWidth) / 2;
        handX = Math.max(0, Math.min(handX, canvas.width - totalHandWidth));

        if (
          draggingCard === null &&
          y > handY &&
          y < handY + handCardHeightPx * scaleFactor
        ) {
          hoveredCard = null;
          for (let i = playerHand.length - 1; i >= 0; i--) {
            const cardX = handX + i * scaledCardWidth;
            const cardY = handY;
            if (
              x >= cardX &&
              x < cardX + scaledCardWidth &&
              y >= cardY &&
              y < cardY + handCardHeightPx * scaleFactor
            ) {
              hoveredCard = i;
              break;
            }
          }
        } else if (draggingCard === null) {
          hoveredCard = null;
        }

        const boardWidth = boardWidthPx * scaleFactor;
        const boardHeight = boardHeightPx * scaleFactor;
        const cellWidth = boardWidth / 3;
        const cellHeight = boardHeight / 3;
        const boardX = (canvas.width - boardWidth) / 2;

        highlightedCell = -1;
        if (
          x >= boardX &&
          x < boardX + boardWidth &&
          y >= boardY &&
          y < boardY + boardHeight
        ) {
          const col = Math.floor((x - boardX) / cellWidth);
          const row = Math.floor((y - boardY) / cellHeight);
          const index = row * 3 + col;
          if (!board[index]) highlightedCell = index;
        }

        drawRequested = true;
      }

      function handleEnd() {
        if (draggingCard === null) return;
        const boardWidth = boardWidthPx * scaleFactor;
        const boardHeight = boardHeightPx * scaleFactor;
        const cellWidth = boardWidth / 3;
        const cellHeight = boardHeight / 3;
        const boardX = (canvas.width - boardWidth) / 2;
        const boardY =
          aiHandY * scaleFactor +
          aiCardHeightPx * scaleFactor +
          boardTopMargin * scaleFactor;
        if (
          dragX >= boardX &&
          dragX < boardX + boardWidth &&
          dragY >= boardY &&
          dragY < boardY + boardHeight
        ) {
          const col = Math.floor((dragX - boardX) / cellWidth);
          const row = Math.floor((dragY - boardY) / cellHeight);
          const index = row * 3 + col;
          if (!board[index]) {
            board[index] = playerHand[draggingCard];
            checkCapture(index, board[index]);
            playerHand.splice(draggingCard, 1);
            currentPlayer = "ai";
            try {
              window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            } catch (e) {
              console.warn("Haptic feedback failed:", e);
            }
            if (
              board.every((cell) => cell) ||
              (playerHand.length === 0 && aiHand.length === 0)
            ) {
              endGame();
            } else {
              setTimeout(aiMove, 1000);
            }
          }
        }
        draggingCard = null;
        hoveredCard = null;
        highlightedCell = -1;
        drawRequested = true;
      }

      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        handleStart(
          (touch.clientX - rect.left) * (canvas.width / rect.width),
          (touch.clientY - rect.top) * (canvas.height / rect.height)
        );
      });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        handleMove(
          (touch.clientX - rect.left) * (canvas.width / rect.width),
          (touch.clientY - rect.top) * (canvas.height / rect.height)
        );
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        handleEnd();
      });

      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        handleStart(
          (e.clientX - rect.left) * (canvas.width / rect.width),
          (e.clientY - rect.top) * (canvas.height / rect.height)
        );
      });

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        handleMove(
          (e.clientX - rect.left) * (canvas.width / rect.width),
          (e.clientY - rect.top) * (canvas.height / rect.height)
        );
      });

      canvas.addEventListener("mouseup", () => {
        handleEnd();
      });

      window.addEventListener("resize", resizeCanvas);

      let lastFrameTime = 0;
      function gameLoop(time) {
        if (!drawRequested && time - lastFrameTime < 16) {
          requestAnimationFrame(gameLoop);
          return;
        }
        lastFrameTime = time;
        draw();
        requestAnimationFrame(gameLoop);
      }

      function draw() {
        if (!drawRequested) return;
        drawRequested = false;

        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (levelScreenVisible && Date.now() - levelScreenStartTime < 3000) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.font = "48px 'Bangers'";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
          ctx.shadowBlur = 2;
          const gradient = ctx.createLinearGradient(
            canvas.width / 2 - 100 * scaleFactor,
            0,
            canvas.width / 2 + 100 * scaleFactor,
            0
          );
          gradient.addColorStop(0, "#D63CE1");
          gradient.addColorStop(1, "#31ff83");
          ctx.fillStyle = gradient;
          ctx.fillText(
            `Level ${level}`,
            canvas.width / 2,
            canvas.height / 2 - 60 * scaleFactor
          );
          ctx.font = "36px 'Bangers'";
          ctx.fillStyle = "#ffffff";
          ctx.fillText(opponentName, canvas.width / 2, canvas.height / 2);
          ctx.font = "24px 'Bangers'";
          ctx.fillStyle = "#ffffff";
          ctx.fillText(
            "Rules",
            canvas.width / 2,
            canvas.height / 2 + 60 * scaleFactor
          );
          ctx.fillStyle = "#D63CE1";
          const rulesText =
            activeRules.length > 0 ? activeRules.join(", ") : "None";
          ctx.fillText(
            rulesText,
            canvas.width / 2,
            canvas.height / 2 + 90 * scaleFactor
          );
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          drawRequested = true;
          return;
        } else {
          levelScreenVisible = false;
        }

        if (cardStealScreenVisible || cardSelectionScreenVisible) {
          document.getElementById("infoButton").style.display = "none";
          drawRequested = true;
          return;
        }

        document.getElementById("infoButton").style.display =
          !tutorialVisible && !gameOver ? "flex" : "none";

        ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
        for (let y = 0; y < canvas.height; y += 10 * scaleFactor) {
          ctx.fillRect(0, y, canvas.width, 2 * scaleFactor);
        }

        const headerHeight = 60 * scaleFactor;
        ctx.font = "20px 'Bangers'";
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
        ctx.shadowBlur = 2;
        ctx.fillText(
          `Score: ${totalScore}`,
          canvas.width / 2 - 50 * scaleFactor,
          30 * scaleFactor
        );
        const timerText = `${Math.floor(gameTime / 60)}:${(gameTime % 60)
          .toString()
          .padStart(2, "0")}`;
        ctx.fillText(
          timerText,
          canvas.width / 2 + 50 * scaleFactor,
          30 * scaleFactor
        );
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;

        const boardWidth = boardWidthPx * scaleFactor;
        const boardHeight = boardHeightPx * scaleFactor;
        const cellWidth = boardWidth / 3;
        const cellHeight = boardHeight / 3;
        const boardX = (canvas.width - boardWidth) / 2;
        const boardY =
          aiHandY * scaleFactor +
          aiCardHeightPx * scaleFactor +
          boardTopMargin * scaleFactor;

        ctx.fillStyle = "#333333";
        ctx.fillRect(boardX, boardY, boardWidth, boardHeight);
        if (boardImage.complete && boardImage.naturalWidth) {
          ctx.drawImage(boardImage, boardX, boardY, boardWidth, boardHeight);
        }

        if (highlightedCell >= 0 && !board[highlightedCell]) {
          const row = Math.floor(highlightedCell / 3);
          const col = highlightedCell % 3;
          ctx.fillStyle = `rgba(255, 255, 255, ${
            0.2 + 0.1 * Math.sin(Date.now() / 200)
          })`;
          ctx.fillRect(
            boardX + col * cellWidth,
            boardY + row * cellHeight,
            cellWidth,
            cellHeight
          );
        }

        board.forEach((card, i) => {
          if (card) {
            const row = Math.floor(i / 3);
            const col = i % 3;
            const flip = flippingCards.find((f) => f.index === i);
            if (flip) {
              ctx.save();
              ctx.translate(
                boardX + col * cellWidth + cellWidth / 2,
                boardY + row * cellHeight + cellHeight / 2
              );
              flip.ease = Math.sin((flip.progress * Math.PI) / 2);
              const angle = flip.ease * Math.PI;
              ctx.scale(Math.cos(angle), 1);
              ctx.translate(-cellWidth / 2, -cellHeight / 2);
              const oldOwner = card.owner === "player" ? "ai" : "player";
              drawCard(
                0,
                0,
                card,
                cardWidthPx,
                cardHeightPx,
                false,
                false,
                false,
                oldOwner,
                false,
                flip.ease
              );
              ctx.restore();
              flip.progress += 0.1 / 5;
              if (flip.progress >= 1) {
                flippingCards = flippingCards.filter((f) => f.index !== i);
              }
            } else {
              drawCard(
                boardX + col * cellWidth,
                boardY + row * cellHeight,
                card,
                cardWidthPx,
                cardHeightPx
              );
            }
          }
        });

        const scaledCardWidth = handCardWidthPx * scaleFactor;
        const playerTotalHandWidth = scaledCardWidth * playerHand.length;
        let playerHandX = (canvas.width - playerTotalHandWidth) / 2;
        playerHandX = Math.max(
          0,
          Math.min(playerHandX, canvas.width - playerTotalHandWidth)
        );
        const handY = boardY + boardHeightPx * scaleFactor + 20 * scaleFactor;

        playerHand.forEach((card, i) => {
          if (i !== draggingCard && i !== hoveredCard) {
            drawCard(
              playerHandX + i * scaledCardWidth,
              handY,
              card,
              handCardWidthPx,
              handCardHeightPx,
              selectedCard === i,
              false,
              false,
              null,
              false
            );
          }
        });

        if (
          hoveredCard !== null &&
          hoveredCard !== draggingCard &&
          playerHand[hoveredCard]
        ) {
          drawCard(
            playerHandX + hoveredCard * scaledCardWidth,
            handY,
            playerHand[hoveredCard],
            handCardWidthPx,
            handCardHeightPx,
            selectedCard === hoveredCard,
            false,
            false,
            null,
            true
          );
        }

        const aiScaledCardWidth = aiCardWidthPx * scaleFactor;
        const aiTotalHandWidth = aiScaledCardWidth * aiHand.length;
        let aiHandX = (canvas.width - aiTotalHandWidth) / 2;
        aiHandX = Math.max(
          0,
          Math.min(aiHandX, canvas.width - aiTotalHandWidth)
        );

        aiHand.forEach((card, i) => {
          drawCard(
            aiHandX + i * aiScaledCardWidth,
            aiHandY * scaleFactor,
            card,
            aiCardWidthPx,
            aiCardHeightPx,
            false,
            false,
            activeRules.includes("Open") ? false : true
          );
        });

        if (draggingCard !== null && playerHand[draggingCard]) {
          drawCard(
            dragX + dragOffsetX,
            dragY + dragOffsetY,
            playerHand[draggingCard],
            handCardWidthPx,
            handCardHeightPx,
            true,
            true,
            false,
            null,
            true
          );
        }

        ctx.font = "20px 'Bangers'";
        ctx.textAlign = "center";
        const indicatorXLeft = 35 * scaleFactor;
        const indicatorXRight = 465 * scaleFactor;
        const indicatorY = canvas.height / 2;
        ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
        ctx.shadowBlur = 2;
        ctx.fillStyle = "#31ff83";
        ctx.fillText("AI", indicatorXLeft, indicatorY - 30 * scaleFactor);
        ctx.font = "56px 'Bangers'";
        ctx.fillText(aiScore, indicatorXLeft, indicatorY + 30 * scaleFactor);
        ctx.font = "20px 'Bangers'";
        ctx.fillStyle = "#D63CE1";
        ctx.fillText("YOU", indicatorXRight, indicatorY - 30 * scaleFactor);
        ctx.font = "56px 'Bangers'";
        ctx.fillText(
          playerScore,
          indicatorXRight,
          indicatorY + 30 * scaleFactor
        );
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;

        if (startMessage.opacity > 0 && Date.now() - startMessage.time < 3000) {
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.fillRect(
            canvas.width / 2 - 100 * scaleFactor,
            canvas.height / 2 - 20 * scaleFactor,
            200 * scaleFactor,
            40 * scaleFactor
          );
          ctx.fillStyle = "#000000";
          ctx.font = "30px 'Bangers'";
          ctx.textAlign = "center";
          ctx.fillText(startMessage.text, canvas.width / 2, canvas.height / 2);
          startMessage.opacity -= 0.0167;
          drawRequested = true;
        }

        if (ruleMessage.opacity > 0 && Date.now() - ruleMessage.time < 3000) {
          ctx.fillStyle = "#000000";
          ctx.font = "36px 'Bangers'";
          ctx.textAlign = "center";
          ctx.shadowColor = "rgba(255, 255, 255, 0.7)";
          ctx.shadowBlur = 4;
          ctx.fillText(
            ruleMessage.text,
            canvas.width / 2,
            canvas.height / 2 - 30 * scaleFactor
          );
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ruleMessage.opacity -= 0.0167;
          drawRequested = true;
        }

        if (
          gameOver &&
          !cardStealScreenVisible &&
          !cardSelectionScreenVisible
        ) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#ffffff";
          ctx.font = "36px 'Bangers'";
          ctx.textAlign = "center";
          const result =
            playerScore > aiScore
              ? "You Win!"
              : playerScore < aiScore
              ? "AI Wins!"
              : "DRAW";
          ctx.fillText(result, canvas.width / 2, canvas.height / 2);
        }

        if (flippingCards.length > 0) {
          drawRequested = true;
        }
      }
    </script>
  </body>
</html>
